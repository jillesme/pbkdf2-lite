/**
 * Provides a class for hashing and verifying passwords using PBKDF2 with SHA-256,
 * optimized for performance within constrained environments like Cloudflare Workers
 * by leveraging the native Web Crypto API (SubtleCrypto).
 *
 * IMPORTANT SECURITY & PERFORMANCE NOTE:
 * The PBKDF2_ITERATIONS constant is the primary factor determining both security
 * and performance. Higher iterations mean better security against brute-force attacks
 * but require more CPU time. 
 */

/**
 * Default values for PBKDF2 parameters
 */
const DEFAULT_SALT_LENGTH_BYTES = 16;
const DEFAULT_KEY_LENGTH_BITS = 256;
const DEFAULT_HASH_FUNCTION = "SHA-256";
const DEFAULT_ALGORITHM_ID = "PBKDF2-SHA256";

/**
 * Converts a Uint8Array (byte array) to a hexadecimal string.
 */
function bytesToHex(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");
}

/**
 * Converts a hexadecimal string back to a Uint8Array (byte array).
 * Throws an error if the hex string is invalid (e.g., odd length).
 */
function hexToBytes(hex: string): Uint8Array {
  if (hex.length % 2 !== 0) {
    throw new Error("Invalid hex string: Odd length.");
  }
  const byteLength = hex.length / 2;
  const bytes = new Uint8Array(byteLength);
  for (let i = 0; i < byteLength; i++) {
    const byteHex = hex.substring(i * 2, i * 2 + 2);
    const byte = parseInt(byteHex, 16);
    if (isNaN(byte)) {
      throw new Error(
        `Invalid hex string: Contains non-hex character at index ${i * 2}.`,
      );
    }
    bytes[i] = byte;
  }
  return bytes;
}

/**
 * PBKDF2Lite class provides methods for password hashing and verification
 * optimized for edge environments with constrained CPU resources.
 */
export class PBKDF2Lite {
  private iterations: number;
  private saltLength: number;
  private keyLength: number;
  private hashFunction: string;
  private algorithmId: string;

  /**
   * Creates a new PBKDF2Lite instance with the specified parameters.
   * 
   * @param iterations - The number of PBKDF2 iterations. Higher values are more secure but slower.
   * @param options - Optional configuration parameters.
   */
  constructor(
    iterations: number = 60000,
    options: {
      saltLength?: number;
      keyLength?: number;
      hashFunction?: string;
      algorithmId?: string;
    } = {}
  ) {
    this.iterations = iterations;
    this.saltLength = options.saltLength || DEFAULT_SALT_LENGTH_BYTES;
    this.keyLength = options.keyLength || DEFAULT_KEY_LENGTH_BITS;
    this.hashFunction = options.hashFunction || DEFAULT_HASH_FUNCTION;
    this.algorithmId = options.algorithmId || DEFAULT_ALGORITHM_ID;
  }

  /**
   * Extracts the iteration count from a hash string.
   * 
   * @param hashString - The hash string in the format "algorithm$iterations$salt$hash"
   * @returns The number of iterations, or null if the hash format is invalid
   */
  getIterationsFromHash(hashString: string): number | null {
    const parts = hashString.split("$");
    if (parts.length !== 4) {
      return null;
    }
    
    const iterations = parseInt(parts[1], 10);
    return isNaN(iterations) || iterations <= 0 ? null : iterations;
  }

  /**
   * Hashes a plaintext password using PBKDF2 with a generated salt.
   * 
   * @param password - The plaintext password to hash.
   * @returns A promise that resolves to the hash string in the format: "algorithm$iterations$salt$hash".
   */
  async hash(password: string): Promise<string> {
    // 1. Generate a cryptographically secure random salt.
    const salt = crypto.getRandomValues(new Uint8Array(this.saltLength));

    // 2. Encode the plaintext password into a buffer (Uint8Array).
    const encoder = new TextEncoder();
    const passwordBuffer = encoder.encode(password);

    // 3. Import the password buffer as a raw key material suitable for PBKDF2.
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      passwordBuffer,
      { name: "PBKDF2" },
      false,
      ["deriveBits"],
    );

    // 4. Derive the cryptographic hash using PBKDF2.
    const derivedBits = await crypto.subtle.deriveBits(
      {
        name: "PBKDF2",
        salt: salt,
        iterations: this.iterations,
        hash: this.hashFunction,
      },
      keyMaterial,
      this.keyLength,
    );

    // 5. Convert the derived bits and salt to hex strings.
    const hashBytes = new Uint8Array(derivedBits);
    const hashHex = bytesToHex(hashBytes);
    const saltHex = bytesToHex(salt);

    // 6. Format the output string for storage.
    return `${this.algorithmId}$${this.iterations}$${saltHex}$${hashHex}`;
  }

  /**
   * Verifies a plaintext password against a stored hash string.
   *
   * @param storedHashString - The hash string previously generated by `hash()`.
   *                           Format: "algorithm$iterations$salt$hash"
   * @param providedPassword - The plaintext password attempt provided by the user.
   * @returns A promise that resolves to `true` if the password matches the hash,
   *          `false` otherwise. Returns `false` if the stored hash format is invalid.
   */
  async verify(storedHashString: string, providedPassword: string): Promise<boolean> {
    // 1. Split the stored hash string into its components.
    const parts = storedHashString.split("$");
    if (parts.length !== 4) {
      console.error("Invalid stored hash format.");
      return false; // Hash string doesn't match the expected format.
    }

    // 2. Extract the components: algorithm, iterations, salt (hex), and stored hash (hex).
    const [algorithm, iterationsStr, saltHex, storedHashHex] = parts;

    // 3. Basic validation of extracted components.
    if (algorithm !== this.algorithmId) {
      console.error(
        `Algorithm mismatch: Expected ${this.algorithmId}, got ${algorithm}`,
      );
      return false;
    }

    const iterations = parseInt(iterationsStr, 10);
    if (isNaN(iterations) || iterations <= 0) {
      console.error(`Invalid iterations count: ${iterationsStr}`);
      return false;
    }

    let salt: Uint8Array;
    let storedHashBytes: Uint8Array;
    try {
      salt = hexToBytes(saltHex);
      storedHashBytes = hexToBytes(storedHashHex);
    } catch (error) {
      console.error(
        `Error decoding hex strings: ${error instanceof Error ? error.message : String(error)}`,
      );
      return false;
    }

    // 4. Encode the provided password attempt into a buffer.
    const encoder = new TextEncoder();
    const passwordBuffer = encoder.encode(providedPassword);

    // 5. Import the provided password buffer as key material.
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      passwordBuffer,
      { name: "PBKDF2" },
      false,
      ["deriveBits"],
    );

    // 6. Derive the hash for the provided password using the stored salt and iterations.
    const derivedBits = await crypto.subtle.deriveBits(
      {
        name: "PBKDF2",
        salt: salt,
        iterations: iterations,
        hash: this.hashFunction,
      },
      keyMaterial,
      this.keyLength,
    );

    const derivedHashBytes = new Uint8Array(derivedBits);

    // 7. Compare the newly derived hash with the stored hash in a constant-time manner.
    if (derivedHashBytes.length !== storedHashBytes.length) {
      return false;
    }

    let difference = 0;
    for (let i = 0; i < derivedHashBytes.length; i++) {
      difference |= derivedHashBytes[i] ^ storedHashBytes[i];
    }

    return difference === 0;
  }
}

// Export the class as default
export default PBKDF2Lite;

// For backward compatibility, also export the function-based API
export async function hashPassword(password: string): Promise<string> {
  const hasher = new PBKDF2Lite();
  return hasher.hash(password);
}

export async function verifyPassword(
  storedHashString: string,
  providedPassword: string
): Promise<boolean> {
  const hasher = new PBKDF2Lite();
  return hasher.verify(storedHashString, providedPassword);
}
